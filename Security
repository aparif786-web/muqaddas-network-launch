# Security Best Practices for Software Development

Here's a comprehensive guide to implementing security in your software projects:

---

## **1. Authentication & Authorization**

### **Secure Authentication Implementation**

```javascript
// Using bcrypt for password hashing
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

class AuthService {
    /**
     * Hash password securely
     * @param {string} password - Plain text password
     * @returns {Promise<string>} Hashed password
     */
    async hashPassword(password) {
        const saltRounds = 12; // Higher = more secure but slower
        return await bcrypt.hash(password, saltRounds);
    }

    /**
     * Verify password
     * @param {string} password - Plain text password
     * @param {string} hash - Stored hash
     * @returns {Promise<boolean>} Match result
     */
    async verifyPassword(password, hash) {
        return await bcrypt.compare(password, hash);
    }

    /**
     * Generate JWT token
     * @param {Object} payload - User data
     * @returns {string} JWT token
     */
    generateToken(payload) {
        return jwt.sign(
            payload,
            process.env.JWT_SECRET,
            { 
                expiresIn: '24h',
                algorithm: 'HS256'
            }
        );
    }

    /**
     * Verify JWT token
     * @param {string} token - JWT token
     * @returns {Object} Decoded payload
     */
    verifyToken(token) {
        try {
            return jwt.verify(token, process.env.JWT_SECRET);
        } catch (error) {
            throw new Error('Invalid token');
        }
    }
}
```

---

## **2. Input Validation & Sanitization**

```javascript
const validator = require('validator');
const xss = require('xss');

class InputValidator {
    /**
     * Validate and sanitize user input
     * @param {Object} data - User input data
     * @returns {Object} Validated data
     */
    validateUserInput(data) {
        const errors = [];

        // Email validation
        if (!validator.isEmail(data.email)) {
            errors.push('Invalid email format');
        }

        // Password strength
        if (!validator.isStrongPassword(data.password, {
            minLength: 8,
            minLowercase: 1,
            minUppercase: 1,
            minNumbers: 1,
            minSymbols: 1
        })) {
            errors.push('Password too weak');
        }

        // Sanitize strings to prevent XSS
        const sanitized = {
            email: validator.normalizeEmail(data.email),
            name: xss(validator.trim(data.name)),
            phone: validator.trim(data.phone)
        };

        if (errors.length > 0) {
            throw new Error(errors.join(', '));
        }

        return sanitized;
    }

    /**
     * Prevent SQL injection
     * @param {string} input - User input
     * @returns {string} Escaped input
     */
    escapeSQLInput(input) {
        return input.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, (char) => {
            switch (char) {
                case "\0": return "\\0";
                case "\x08": return "\\b";
                case "\x09": return "\\t";
                case "\x1a": return "\\z";
                case "\n": return "\\n";
                case "\r": return "\\r";
                case "\"":
                case "'":
                case "\\":
                case "%":
                    return "\\" + char;
                default:
                    return char;
            }
        });
    }
}
```

---

## **3. SQL Injection Prevention**

```javascript
// ‚ùå BAD - Vulnerable to SQL injection
const query = `SELECT * FROM users WHERE email = '${userEmail}'`;

// ‚úÖ GOOD - Using parameterized queries
const query = 'SELECT * FROM users WHERE email = ?';
db.query(query, [userEmail]);

// ‚úÖ BETTER - Using ORM (Sequelize example)
const user = await User.findOne({
    where: { email: userEmail }
});
```

---

## **4. Cross-Site Scripting (XSS) Prevention**

```javascript
const helmet = require('helmet');
const express = require('express');
const app = express();

// Set security headers
app.use(helmet());

// Content Security Policy
app.use(helmet.contentSecurityPolicy({
    directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"]
    }
}));

// Sanitize output
function escapeHTML(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\//g, '&#x2F;');
}
```

---

## **5. CSRF Protection**

```javascript
const csrf = require('csurf');
const cookieParser = require('cookie-parser');

// Setup CSRF protection
const csrfProtection = csrf({ cookie: true });

app.use(cookieParser());

// Apply to routes
app.get('/form', csrfProtection, (req, res) => {
    res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/process', csrfProtection, (req, res) => {
    // Process form
});
```

---

## **6. Rate Limiting**

```javascript
const rateLimit = require('express-rate-limit');

// General rate limiter
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: 'Too many requests, please try again later'
});

// Strict limiter for authentication
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5, // 5 attempts per 15 minutes
    skipSuccessfulRequests: true
});

app.use('/api/', limiter);
app.use('/api/auth/', authLimiter);
```

---

## **7. Secure Session Management**

```javascript
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');

const redisClient = redis.createClient();

app.use(session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: true, // HTTPS only
        httpOnly: true, // Prevent JavaScript access
        maxAge: 1000 * 60 * 60 * 24, // 24 hours
        sameSite: 'strict' // CSRF protection
    }
}));
```

---

## **8. Data Encryption**

```javascript
const crypto = require('crypto');

class EncryptionService {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
    }

    /**
     * Encrypt sensitive data
     * @param {string} text - Plain text
     * @returns {string} Encrypted text
     */
    encrypt(text) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
        
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return JSON.stringify({
            iv: iv.toString('hex'),
            encryptedData: encrypted,
            authTag: authTag.toString('hex')
        });
    }

    /**
     * Decrypt sensitive data
     * @param {string} encryptedText - Encrypted text
     * @returns {string} Plain text
     */
    decrypt(encryptedText) {
        const { iv, encryptedData, authTag } = JSON.parse(encryptedText);
        
        const decipher = crypto.createDecipheriv(
            this.algorithm,
            this.key,
            Buffer.from(iv, 'hex')
        );
        
        decipher.setAuthTag(Buffer.from(authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}
```

---

## **9. Secure File Upload**

```javascript
const multer = require('multer');
const path = require('path');

// Configure file upload
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + crypto.randomBytes(6).toString('hex');
        cb(null, uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB limit
    },
    fileFilter: (req, file, cb) => {
        // Allowed file types
        const allowedTypes = /jpeg|jpg|png|pdf/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);

        if (extname && mimetype) {
            return cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});
```

---

## **10. Environment Variables Security**

```javascript
// .env file (never commit to Git!)
JWT_SECRET=your-super-secret-jwt-key-here
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
ENCRYPTION_KEY=64-character-hex-string
SESSION_SECRET=another-secret-key

// .gitignore
.env
.env.local
.env.production
```

```javascript
// Load environment variables
require('dotenv').config();

// Validate required environment variables
const requiredEnvVars = [
    'JWT_SECRET',
    'DATABASE_URL',
    'ENCRYPTION_KEY'
];

requiredEnvVars.forEach(varName => {
    if (!process.env[varName]) {
        throw new Error(`Missing required environment variable: ${varName}`);
    }
});
```

---

## **11. Security Headers**

```javascript
const helmet = require('helmet');

app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"],
            fontSrc: ["'self'"],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'"],
            frameSrc: ["'none'"]
        }
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    },
    noSniff: true,
    xssFilter: true,
    hidePoweredBy: true
}));
```

---

## **12. Logging & Monitoring**

```javascript
const winston = require('winston');

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ]
});

// Log security events
function logSecurityEvent(event, details) {
    logger.warn('Security Event', {
        event,
        details,
        timestamp: new Date().toISOString(),
        ip: details.ip,
        userAgent: details.userAgent
    });
}

// Example usage
app.post('/login', async (req, res) => {
    try {
        // Login logic
    } catch (error) {
        logSecurityEvent('FAILED_LOGIN', {
            ip: req.ip,
            userAgent: req.get('user-agent'),
            email: req.body.email
        });
    }
});
```

---

## **Security Checklist**

```markdown
### Pre-Deployment Security Checklist

- [ ] All passwords hashed with bcrypt (salt rounds ‚â• 12)
- [ ] JWT tokens with expiration
- [ ] Input validation on all user inputs
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS protection (sanitize output)
- [ ] CSRF tokens implemented
- [ ] Rate limiting on all endpoints
- [ ] HTTPS enforced (redirect HTTP to HTTPS)
- [ ] Security headers configured (Helmet.js)
- [ ] Sensitive data encrypted at rest
- [ ] Environment variables secured
- [ ] File upload restrictions
- [ ] Session management secure
- [ ] Error messages don't leak information
- [ ] Logging and monitoring active
- [ ] Regular security audits scheduled
- [ ] Dependency vulnerabilities checked (npm audit)
- [ ] CORS properly configured
- [ ] API authentication required
- [ ] Database access restricted
```

---

These security practices will help protect your application from common vulnerabilities and attacks! üîí
